// Generated by CoffeeScript 1.3.3
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['perlin'], function(PerlinNoise) {
    var Game;
    Game = (function() {

      function Game() {
        var border_tile, x, y;
        this.name = 'Comrade';
        this.ui_height = 30;
        this.border = 1;
        border_tile = 2;
        this.width = 20 + this.border;
        this.height = 20 + this.border;
        this.tile_size = 30;
        this.screen_width = this.width * this.tile_size;
        this.screen_height = this.height * this.tile_size + this.ui_height;
        this._num_scenes = 2;
        this.world_width = (this.width * this._num_scenes) - this._num_scenes + 1;
        this.world_height = (this.height * this._num_scenes) - this._num_scenes + 1;
        this.num_trees = 100;
        this.perlin_size = 5;
        this.perlin_z_axis = .8;
        this.input = null;
        this.solid_things = [2, 3, 5];
        this.resource_ids = [2, 3, 5];
        this.empty_tiles = [];
        this.objects = (function() {
          var _i, _ref, _results;
          _results = [];
          for (x = _i = 0, _ref = this.world_width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
            _results.push((function() {
              var _j, _ref1, _results1;
              _results1 = [];
              for (y = _j = 0, _ref1 = this.world_height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
                _results1.push(0);
              }
              return _results1;
            }).call(this));
          }
          return _results;
        }).call(this);
        this.obstacles = (function() {
          var _i, _ref, _results;
          _results = [];
          for (x = _i = 0, _ref = this.world_width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
            _results.push((function() {
              var _j, _ref1, _results1;
              _results1 = [];
              for (y = _j = 0, _ref1 = this.world_height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
                _results1.push(0);
              }
              return _results1;
            }).call(this));
          }
          return _results;
        }).call(this);
        this.world = (function() {
          var _i, _ref, _results;
          _results = [];
          for (x = _i = 0, _ref = this.world_width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
            _results.push((function() {
              var _j, _ref1, _results1;
              _results1 = [];
              for (y = _j = 0, _ref1 = this.world_height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
                _results1.push(border_tile);
              }
              return _results1;
            }).call(this));
          }
          return _results;
        }).call(this);
        this.generate_world();
        this.add_trees();
      }

      Game.prototype.add_trees = function() {
        var i, index, tree, _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = this.num_trees; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          index = Math.floor(Math.random() * this.empty_tiles.length);
          tree = this.empty_tiles.splice(index, 1)[0];
          this.objects[tree.x][tree.y] = 5;
          _results.push(this.obstacles[tree.x][tree.y] = 1);
        }
        return _results;
      };

      Game.prototype.generate_world = function() {
        var tile, x, y, _i, _ref, _results;
        _results = [];
        for (x = _i = 1, _ref = this.world_width - 2; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (y = _j = 1, _ref1 = this.world_height - 2; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 1 <= _ref1 ? ++_j : --_j) {
              tile = this.block_type(PerlinNoise(this.perlin_size * x / this.world_width, this.perlin_size * y / this.world_height, this.perlin_z_axis));
              this.world[x][y] = tile;
              if (__indexOf.call(this.solid_things, tile) < 0) {
                this.empty_tiles.push({
                  x: x,
                  y: y
                });
                _results1.push(this.obstacles[x][y] = 1);
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      };

      Game.prototype.block_type = function(height) {
        if (height <= .3) {
          return 2;
        }
        if ((.3 < height && height <= .4)) {
          return 4;
        }
        if ((.4 < height && height <= .7)) {
          return 1;
        }
        return 3;
      };

      return Game;

    })();
    return new Game;
  });

}).call(this);
