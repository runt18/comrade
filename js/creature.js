// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['entity', 'game', 'scene', 'astar'], function(Entity, g, s, astar) {
    var Creature;
    return Creature = (function(_super) {

      __extends(Creature, _super);

      function Creature() {
        return Creature.__super__.constructor.apply(this, arguments);
      }

      Creature.prototype.move_scene = function() {};

      Creature.prototype.set_stats = function() {
        this.health = 5;
        this.attack = 1;
        this.pathfind();
        return this.moving_along_path = false;
      };

      Creature.prototype.create_images = function() {
        return this.images = {
          up: {
            x: 1,
            y: 4
          },
          left: {
            x: 3,
            y: 4
          },
          down: {
            x: 2,
            y: 4
          },
          right: {
            x: 4,
            y: 4
          }
        };
      };

      Creature.prototype.pathfind = function(end_coords) {
        var end, start;
        start = s.current.graph.nodes[this.pos.x][this.pos.y];
        if (!end_coords) {
          end_coords = s.current.empty_tiles[Math.floor(Math.random() * s.current.empty_tiles.length)];
        }
        end = s.current.graph.nodes[end_coords.x][end_coords.y];
        this.path = astar.search(s.current.graph.nodes, start, end);
        this.pathi = 0;
        return this.moving_along_path = true;
      };

      Creature.prototype.move_along_path = function() {
        var axis, direction, next_point;
        if (this.pathi === this.path.length) {
          this.moving_along_path = false;
          return;
        }
        next_point = this.path[this.pathi];
        if (next_point.x === Math.round(this.pos.x)) {
          direction = next_point.y - this.pos.y;
          axis = 'y';
        } else {
          direction = next_point.x - this.pos.x;
          axis = 'x';
        }
        this.move(axis, direction);
        return this.pathi += 1;
      };

      return Creature;

    })(Entity);
  });

}).call(this);
